


def zip_map(
        func, in_streams, out_stream,
        state=None, call_streams=None, name='zip_map',
        *args, **kwargs): 
    """
    Parameters
    ----------
        func: function
           function from a list (and possibly state,
           args and kwargs) to a single element of
           the output stream. The list has one element
           from each input stream.
        in_streams: list of Stream
           The list of input streams of the agent
        out_stream: Stream
           The single output stream of the agent
        state: object
           The state of the agent
        call_streams: list of Stream
           The list of call_streams. A new value in any stream in this
           list causes a state transition of this agent.
        name: str
           Name of the agent created by this function.
    Returns
    -------
        Agent.
         The agent created by this function.

    """
    check_merge_agent_arguments(func, in_streams, out_stream, call_streams, name)
    check_num_args_in_func(state, name, func, args, kwargs)
    num_in_streams = len(in_streams)

    # The transition function for this agent.
    def transition(in_lists, state):
        check_in_lists_type(name, in_lists, num_in_streams)
        # input_snapshots is a list of snapshots.
        # Each snapshot is a list containing one element for each
        # input stream.
        input_snapshots = list(zip(*[v.list[v.start:v.stop] for v in in_lists]))
        # If the new input data is empty then return empty lists for
        # each output stream, and leave the state and the starting point
        # for each input stream unchanged.
        if not input_snapshots:
            return ([[]], state, [v.start for v in in_lists])

        # output_list[i] will be set to the result of func applied
        # to the list consisting of the i-th value in 
        # each of the input streams
        output_list = [ [] for lst in input_snapshots]

        for i, snapshot in enumerate(input_snapshots):
            assert isinstance(snapshot, list) or isinstance(snapshot, tuple)
            if state is None:
                output_list[i] = func(snapshot, *args, **kwargs)
            else:
                output_list[i], state = func(snapshot, state, *args, **kwargs)

            if output_list[i] is None: output_list[i] = []

        return ([output_list], state, [v.start+len(input_snapshots) for v in in_lists])
    # Finished transition

    # Create agent
    return Agent(in_streams, [out_stream], transition, state, call_streams, name)


def merge_list(func, in_streams, out_stream, state=None,
                        call_streams=None, name=None,
                        *args, **kwargs):
    """
    Parameters
    ----------
        func: function
           function from a list of lists (one list per input stream) to an output list
        in_streams: list of Stream
           The list of input streams of the agent
        out_stream: Stream
           The single output stream of the agent
        state: object
           The state of the agent
        call_streams: list of Stream
           The list of call_streams. A new value in any stream in this
           list causes a state transition of this agent.
        name: Str
           Name of the agent created by this function.
    Returns
    -------
        Agent.
         The agent created by this function.

    """
    # Check the arguments and output error messages if argument types
    # and numbers are incorrect.
    check_merge_agent_arguments(func, in_streams, out_stream, call_streams, name)
    check_num_args_in_func(state, name, func, args, kwargs)

    num_in_streams = len(in_streams)

    # The transition function for this agent.
    def transition(in_lists, state):
        # Check the types of the input lists for the transition.
        check_in_lists_type(name, in_lists, num_in_streams)
        # smallest_list_length is the smallest of all the inputs for
        # this agent.
        smallest_list_length = \
          min(in_list.stop - in_list.start for in_list in in_lists)
        # Check for null transition.
        if smallest_list_length == 0:
            # output_list is []
            # return ([output_list], state,
            #         [in_list.start+smallest_list_length
            #                           for in_list in in_lists])
            return ([[]], state,
                    [in_list.start for in_list in in_lists])
        # input_lists is the list of lists that this agent operates on
        # in this transition.
        input_lists = [in_list.list[
            in_list.start:in_list.start+smallest_list_length]
            for in_list in in_lists]

        # Compute the output generated by this transition.
        if state is None:
            output_list = func(input_lists, *args, **kwargs)
        else:
            ouput_list, state = func(input_lists, state, *args, **kwargs)

        # Return: (1) the list of outputs, one per output stream. The
        #         merge_agent has a single output list.
        #         (2) the new state and
        #         (3) the new starting pointer into this stream for
        #             this agent. Since this agent has read the entire
        #             input_list, move its starting pointer forward by
        #             the length of the input list.
        return ([output_list],
                state,
                [in_list.start+smallest_list_length for in_list in in_lists])
    # Finished transition

    # Create agent with the following parameters:
    # 1. list of input streams. merge has a list, instreams, of input
    # streams. 
    # 2. list of output streams. merge has a single output stream.
    # 3. transition function
    # 4. new state
    # 5. list of calling streams
    # 6. Agent name
    return Agent(in_streams, [out_stream], transition, state, call_streams, name)
